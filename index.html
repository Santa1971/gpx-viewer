<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dtrail GPX 비교 뷰어 (애니메이션)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        
        .pdf-container {
            background: white;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            padding: 20px;
            border-radius: 3px;
        }
        
        .pdf-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
            margin-bottom: 20px;
        }
        
        .pdf-title {
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
        }
        
        .pdf-toolbar {
            display: flex;
            gap: 10px;
        }
        
        .pdf-icon {
            background: #e74c3c;
            color: white;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-weight: bold;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .upload-section-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap; /* For smaller screens */
        }

        .upload-section {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            flex: 1; /* Allow sections to grow */
            min-width: 300px; /* Minimum width for each upload section */
        }
        
        .upload-area {
            border: 2px dashed #e74c3c;
            border-radius: 5px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .upload-area:hover {
            border-color: #c0392b;
            background-color: #f9f9f9;
        }
        
        .upload-area.drag-over {
            border-color: #e74c3c;
            background-color: #feeae8;
        }
        
        .file-input { /* Common class for file inputs */
            display: none;
        }
        
        .info-section-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .info-section {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: none; /* Initially hidden */
            flex: 1;
            min-width: 300px;
        }
        
        .stats-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); /* Adjusted minmax */
            gap: 15px;  /* Adjusted gap */
            margin-bottom: 20px;
        }
        
        .stat-card {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 5px;
        }
        .stat-card.file1 { border-left: 4px solid #e74c3c; } /* Color for file 1 */
        .stat-card.file2 { border-left: 4px solid #3498db; } /* Color for file 2 */

        .stat-title {
            color: #666;
            font-size: 14px;
            margin-bottom: 5px;
        }
        
        .stat-value {
            color: #333;
            font-size: 18px; /* Adjusted font size */
            font-weight: bold;
        }
        
        .km-marker-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        .km-marker-table th, .km-marker-table td {
            padding: 8px; /* Adjusted padding */
            text-align: left;
            border-bottom: 1px solid #ddd;
            font-size: 12px; /* Adjusted font size */
        }
        
        .km-marker-table th {
            background-color: #f2f2f2;
            color: #333;
            font-weight: bold;
        }
        
        .km-marker-table tr:hover {
            background-color: #f5f5f5;
        }
        
        .shared-section { /* For map and chart */
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-top: 20px;
        }

        .map-container {
            width: 100%;
            height: 450px; 
            margin-top: 20px;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }
        
        .elevation-chart {
            width: 100%;
            height: 250px; 
            margin-top: 20px;
            position: relative;
            overflow: hidden;
        }

        #elevation-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .player-controls {
            display: none; /* Initially hidden, shown by JS */
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            background: #f9f9f9;
            padding: 15px;
            border-radius: 5px;
            flex-wrap: wrap; 
        }
        
        .play-pause-btn {
            background: #e74c3c;
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .speed-slider {
            width: 150px;
        }
                
        .chart-position-indicator {
            width: 2px;
            position: absolute;
            top: 0; 
            height: 100%;
            z-index: 100;
            display: none;
            pointer-events: none;
        }
        
        .chart-position-dot {
            width: 10px;
            height: 10px;
            border: 2px solid white; 
            border-radius: 50%;
            position: absolute;
            z-index: 101;
            display: none;
            pointer-events: none;
            transform: translate(-50%, -50%);
        }
        
        .section-title {
            font-size: 20px; 
            color: #2c3e50;
            border-bottom: 2px solid; /* Color set by context */
            padding-bottom: 5px;
            margin-top: 30px;
            margin-bottom: 15px; 
        }
        .section-title.file1 { border-color: #e74c3c; }
        .section-title.file2 { border-color: #3498db; }
        .section-title.shared { border-color: #2c3e50; }
        
        .current-info-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
            flex-grow: 1;
        }
        .current-info {
            display: none; /* Initially hidden, shown by JS */
            gap: 10px; /* Reduced gap */
            background: #f2f2f2;
            padding: 8px; /* Reduced padding */
            border-radius: 5px;
            font-weight: bold;
            font-size: 13px; /* Smaller font */
        }
        .current-info span {
            flex: 1;
            white-space: nowrap;
            min-width: 0; /* Allow shrinking */
        }
        .current-info .label { /* For F1:, F2: labels */
            font-weight:bold;
            flex-basis: auto; 
            flex-grow: 0;
            flex-shrink: 0;
            margin-right: 5px;
        }
        
        .runner-leaflet-div-icon { /* Used by Leaflet for runner icons */
            text-align: center;
            line-height: normal; 
            /* width & height are set by iconSize: null or L.point() in JS */
        }
        .runner-leaflet-div-icon span { /* Style for the content inside divIcon */
            display: inline-block; /* Allows padding and background */
            font-size: 18px; 
            white-space: nowrap; 
            background-color: rgba(255,255,255,0.8); 
            padding: 3px 6px; 
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .legend { margin-top: 10px; margin-bottom:10px; display: flex; gap: 20px; justify-content: center; align-items: center;}
        .legend-item { display: flex; align-items: center; gap: 5px;}
        .legend-color { width: 20px; height: 10px; display: inline-block;}
    </style>
</head>
<body>
    <div class="pdf-container">
        <div class="pdf-header">
            <div class="pdf-title">Dtrail GPX 비교 뷰어 (애니메이션)</div>
            <div class="pdf-toolbar">
                <div class="pdf-icon">GPX</div>
            </div>
        </div>
        
        <div class="container">
            <div class="upload-section-container">
                <div class="upload-section">
                    <h2 class="section-title file1">GPX 파일 1 업로드</h2>
                    <div class="upload-area" id="upload-area-1">
                        <p>GPX 파일을 여기에 드래그 앤 드롭하거나 클릭하여 선택하세요</p>
                        <input type="file" id="file-input-1" class="file-input" accept=".gpx" data-file-index="1">
                    </div>
                </div>
                <div class="upload-section">
                    <h2 class="section-title file2">GPX 파일 2 업로드</h2>
                    <div class="upload-area" id="upload-area-2">
                        <p>GPX 파일을 여기에 드래그 앤 드롭하거나 클릭하여 선택하세요</p>
                        <input type="file" id="file-input-2" class="file-input" accept=".gpx" data-file-index="2">
                    </div>
                </div>
            </div>

            <div class="shared-section">
                <h2 class="section-title shared">지도 &amp; 경로 애니메이션</h2>
                <div class="legend">
                    <span class="legend-item"><span class="legend-color" style="background-color: #e74c3c;"></span> 파일 1 (🏃)</span>
                    <span class="legend-item"><span class="legend-color" style="background-color: #3498db;"></span> 파일 2 (🚴)</span>
                </div>
                <div class="map-container" id="map">
                    </div>
                 <div class="player-controls" id="player-controls">
                    <button class="play-pause-btn" id="play-pause-btn">▶</button>
                    <div class="speed-control">
                        <span>재생속도:</span>
                        <input type="range" min="0.1" max="5" step="0.1" value="1" class="speed-slider" id="speed-slider">
                        <span id="speed-value">1.0x</span>
                    </div>
                    <div class="current-info-container">
                        <div class="current-info" id="current-info-1">
                            <span class="label" id="current-file-1-label" style="color:#e74c3c;">🏃:</span>
                            <span id="current-distance-1">거리: 0.0km</span>
                            <span id="current-elevation-1">고도: 0m</span>
                            <span id="current-time-1">시간: --:--:--</span>
                        </div>
                        <div class="current-info" id="current-info-2">
                            <span class="label" id="current-file-2-label" style="color:#3498db;">🚴:</span>
                            <span id="current-distance-2">거리: 0.0km</span>
                            <span id="current-elevation-2">고도: 0m</span>
                            <span id="current-time-2">시간: --:--:--</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="shared-section">
                <h2 class="section-title shared">고도 차트</h2>
                 <div class="legend">
                    <span class="legend-item"><span class="legend-color" style="background-color: #e74c3c;"></span> 파일 1 (🏃)</span>
                    <span class="legend-item"><span class="legend-color" style="background-color: #3498db;"></span> 파일 2 (🚴)</span>
                </div>
                <div class="elevation-chart" id="elevation-chart-container"> 
                    <canvas id="elevation-canvas"></canvas>
                </div>
            </div>
            
            <div class="info-section-container">
                <div class="info-section" id="info-section-1">
                    <h2 class="section-title file1">GPX 파일 1 정보</h2>
                    <div id="gpx-info-1">
                        <div class="stats-container" id="stats-container-1"></div>
                        <h3 class="section-title file1">킬로미터 구간별 정보 (파일 1)</h3>
                        <div style="overflow-x: auto;">
                            <table class="km-marker-table">
                                <thead>
                                    <tr>
                                        <th>구간 (km)</th><th>누적 거리</th><th>구간 시간</th><th>누적 시간</th>
                                        <th>구간 상승(m)</th><th>구간 하강(m)</th><th>누적 상승(m)</th><th>누적 하강(m)</th>
                                    </tr>
                                </thead>
                                <tbody id="km-markers-body-1"></tbody>
                            </table>
                        </div>
                    </div>
                </div>
                
                <div class="info-section" id="info-section-2">
                    <h2 class="section-title file2">GPX 파일 2 정보</h2>
                    <div id="gpx-info-2">
                        <div class="stats-container" id="stats-container-2"></div>
                        <h3 class="section-title file2">킬로미터 구간별 정보 (파일 2)</h3>
                        <div style="overflow-x: auto;">
                            <table class="km-marker-table">
                                <thead>
                                    <tr>
                                        <th>구간 (km)</th><th>누적 거리</th><th>구간 시간</th><th>누적 시간</th>
                                        <th>구간 상승(m)</th><th>구간 하강(m)</th><th>누적 상승(m)</th><th>누적 하강(m)</th>
                                    </tr>
                                </thead>
                                <tbody id="km-markers-body-2"></tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>

    <script>
        // DOM Elements
        const uploadArea1 = document.getElementById('upload-area-1');
        const fileInput1 = document.getElementById('file-input-1');
        const infoSection1 = document.getElementById('info-section-1');
        const statsContainer1 = document.getElementById('stats-container-1');
        const kmMarkersTableBody1 = document.getElementById('km-markers-body-1');
        const currentInfo1El = document.getElementById('current-info-1');
        const currentDistance1El = document.getElementById('current-distance-1');
        const currentElevation1El = document.getElementById('current-elevation-1');
        const currentTime1El = document.getElementById('current-time-1');

        const uploadArea2 = document.getElementById('upload-area-2');
        const fileInput2 = document.getElementById('file-input-2');
        const infoSection2 = document.getElementById('info-section-2');
        const statsContainer2 = document.getElementById('stats-container-2');
        const kmMarkersTableBody2 = document.getElementById('km-markers-body-2');
        const currentInfo2El = document.getElementById('current-info-2');
        const currentDistance2El = document.getElementById('current-distance-2');
        const currentElevation2El = document.getElementById('current-elevation-2');
        const currentTime2El = document.getElementById('current-time-2');

        const playerControls = document.getElementById('player-controls');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const speedSlider = document.getElementById('speed-slider');
        const speedValue = document.getElementById('speed-value');
        const elevationChartContainer = document.getElementById('elevation-chart-container');

        let map;
        let elevationChart;
        
        let trackPoints1 = [], trackPoints2 = [];
        let kmMarkers1 = [], kmMarkers2 = [];
        let firstValidTimeInTrack1 = null, firstValidTimeInTrack2 = null;

        // For map layers
        let trackLayer1 = null, trackLayer2 = null;
        let startMarker1 = null, endMarker1 = null;
        let startMarker2 = null, endMarker2 = null;
        let runnerLeafletMarker1 = null, runnerLeafletMarker2 = null;

        // For chart indicators
        let chartPositionIndicator1 = null, chartPositionDot1 = null;
        let chartPositionIndicator2 = null, chartPositionDot2 = null;

        // Playback state
        let animationFrameId;
        let isPlaying = false;
        let normalizedProgress = 0; // 0.0 to 1.0
        let playbackSpeed = 1.0;
        let lastTimestamp = 0; 

        const fileColors = {
            1: { line: '#e74c3c', fill: 'rgba(231, 76, 60, 0.1)', name: '파일 1', runnerEmoji: '🏃' },
            2: { line: '#3498db', fill: 'rgba(52, 152, 219, 0.1)', name: '파일 2', runnerEmoji: '🚴' }
        };

        // Event Listeners
        [uploadArea1, uploadArea2].forEach((area, index) => {
            if (area) {
                const fileInput = index === 0 ? fileInput1 : fileInput2;
                area.addEventListener('click', () => fileInput.click());
                area.addEventListener('dragover', (e) => { 
                    e.preventDefault();
                    area.classList.add('drag-over');
                });
                area.addEventListener('dragleave', () => area.classList.remove('drag-over'));
                area.addEventListener('drop', (e) => {
                    e.preventDefault();
                    area.classList.remove('drag-over');
                    if (e.dataTransfer.files.length) {
                        fileInput.files = e.dataTransfer.files;
                        handleFileUpload({ target: fileInput });
                    }
                });
            }
        });

        if (fileInput1) fileInput1.addEventListener('change', handleFileUpload);
        if (fileInput2) fileInput2.addEventListener('change', handleFileUpload);
        
        if(speedSlider) speedSlider.addEventListener('input', () => {
            playbackSpeed = parseFloat(speedSlider.value);
            if(speedValue) speedValue.textContent = playbackSpeed.toFixed(1) + 'x';
        });
        if(playPauseBtn) playPauseBtn.addEventListener('click', togglePlayPause);

        function checkPlaybackAvailability() {
            const hasFile1 = trackPoints1.length > 0;
            const hasFile2 = trackPoints2.length > 0;

            if (hasFile1 || hasFile2) {
                playerControls.style.display = 'flex';
                if (hasFile1) currentInfo1El.style.display = 'flex'; else currentInfo1El.style.display = 'none';
                if (hasFile2) currentInfo2El.style.display = 'flex'; else currentInfo2El.style.display = 'none';
            } else {
                playerControls.style.display = 'none';
                currentInfo1El.style.display = 'none';
                currentInfo2El.style.display = 'none';
            }
        }

        function handleFileUpload(event) {
            const input = event.target;
            const fileIndex = parseInt(input.dataset.fileIndex);
            const file = input.files[0];

            if (file && file.name.toLowerCase().endsWith('.gpx')) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        resetDataForFile(fileIndex); 
                        parseGPXFile(e.target.result, fileIndex);
                        
                        if (!map) initializeMap();
                        displayMap(); 
                        displayElevationChart();
                        checkPlaybackAvailability();
                        resetAnimation(); 

                    } catch (error) {
                        console.error(`GPX parsing error for file ${fileIndex}:`, error);
                        alert(`GPX 파일 ${fileIndex} 처리 중 오류: ${error.message}`);
                        if (fileIndex === 1 && infoSection1) infoSection1.style.display = 'none';
                        if (fileIndex === 2 && infoSection2) infoSection2.style.display = 'none';
                    }
                };
                reader.onerror = (e) => {
                    console.error(`File ${fileIndex} reading error:`, e);
                    alert(`파일 ${fileIndex} 읽기 오류.`);
                };
                reader.readAsText(file);
            } else if (file) {
                alert('GPX 파일을 선택해주세요.');
            }
        }

        function resetDataForFile(fileIndex) {
            if (fileIndex === 1) {
                trackPoints1 = []; kmMarkers1 = []; firstValidTimeInTrack1 = null;
                if(statsContainer1) statsContainer1.innerHTML = '';
                if(kmMarkersTableBody1) kmMarkersTableBody1.innerHTML = '';
                if(infoSection1) infoSection1.style.display = 'none'; 
                if(trackLayer1 && map) { map.removeLayer(trackLayer1); trackLayer1 = null; }
                if(startMarker1 && map) { map.removeLayer(startMarker1); startMarker1 = null; }
                if(endMarker1 && map) { map.removeLayer(endMarker1); endMarker1 = null; }
                if(runnerLeafletMarker1 && map) { map.removeLayer(runnerLeafletMarker1); runnerLeafletMarker1 = null; }
                removeChartIndicator(1);
            } else { // fileIndex === 2
                trackPoints2 = []; kmMarkers2 = []; firstValidTimeInTrack2 = null;
                if(statsContainer2) statsContainer2.innerHTML = '';
                if(kmMarkersTableBody2) kmMarkersTableBody2.innerHTML = '';
                if(infoSection2) infoSection2.style.display = 'none';
                if(trackLayer2 && map) { map.removeLayer(trackLayer2); trackLayer2 = null; }
                if(startMarker2 && map) { map.removeLayer(startMarker2); startMarker2 = null; }
                if(endMarker2 && map) { map.removeLayer(endMarker2); endMarker2 = null; }
                if(runnerLeafletMarker2 && map) { map.removeLayer(runnerLeafletMarker2); runnerLeafletMarker2 = null; }
                removeChartIndicator(2);
            }
        }

        function parseGPXFile(gpxContent, fileIndex) {
            console.log(`Parsing GPX file ${fileIndex}...`);
            const parser = new DOMParser();
            const gpxDoc = parser.parseFromString(gpxContent, 'text/xml');
            const xmlError = gpxDoc.querySelector('parsererror');

            if (xmlError) {
                console.error(`XML Parsing Error for file ${fileIndex}:`, xmlError.textContent);
                alert(`GPX 파일 ${fileIndex}을 XML로 파싱하는데 실패했습니다.\n오류: ${xmlError.textContent}`);
                return;
            }
            
            let trackPointElements = Array.from(gpxDoc.querySelectorAll('trkpt'));
            if (trackPointElements.length === 0) trackPointElements = Array.from(gpxDoc.querySelectorAll('trkseg > trkpt'));
            if (trackPointElements.length === 0 && gpxDoc.querySelector('trk')) {
                 trackPointElements = Array.from(gpxDoc.querySelector('trk').querySelectorAll('trkpt'));
            }

            if (trackPointElements.length === 0) {
                alert(`GPX 파일 ${fileIndex}에서 유효한 트랙 포인트(<trkpt>)를 찾을 수 없습니다.`);
                return;
            }

            let currentTrackPoints = trackPointElements.map((point, index) => {
                const latAttr = point.getAttribute('lat');
                const lonAttr = point.getAttribute('lon');
                if (!latAttr || !lonAttr) return null;
                const lat = parseFloat(latAttr);
                const lon = parseFloat(lonAttr);
                if (isNaN(lat) || isNaN(lon)) return null;

                const eleNode = point.querySelector('ele');
                const timeNode = point.querySelector('time');
                let ele = null, time = null;
                if (eleNode?.textContent) ele = parseFloat(eleNode.textContent);
                if (isNaN(ele)) ele = null;
                if (timeNode?.textContent) {
                    const parsedTime = new Date(timeNode.textContent);
                    if (!isNaN(parsedTime.getTime())) time = parsedTime;
                }
                return { index: index + 1, lat, lon, ele, time, distance: 0 };
            }).filter(point => point !== null);

            if (currentTrackPoints.length === 0) {
                alert(`GPX 파일 ${fileIndex}에 유효한 좌표 데이터를 가진 트랙 포인트가 없습니다.`);
                return;
            }

            let totalDistance = 0;
            if (currentTrackPoints.length > 0) currentTrackPoints[0].distance = 0;
            for (let i = 1; i < currentTrackPoints.length; i++) {
                const dist = calculateDistance(
                    currentTrackPoints[i-1].lat, currentTrackPoints[i-1].lon,
                    currentTrackPoints[i].lat, currentTrackPoints[i].lon
                );
                totalDistance += dist;
                currentTrackPoints[i].distance = totalDistance;
            }
            
            const firstValidTime = currentTrackPoints.find(p => p.time instanceof Date && !isNaN(p.time.getTime()))?.time || null;

            if (fileIndex === 1) {
                trackPoints1 = currentTrackPoints;
                firstValidTimeInTrack1 = firstValidTime;
                if(infoSection1) infoSection1.style.display = 'block';
                kmMarkers1 = createKilometerMarkers(trackPoints1, firstValidTimeInTrack1);
                displayStatistics(1);
                displayKilometerMarkers(1);
            } else { // fileIndex === 2
                trackPoints2 = currentTrackPoints;
                firstValidTimeInTrack2 = firstValidTime;
                if(infoSection2) infoSection2.style.display = 'block';
                kmMarkers2 = createKilometerMarkers(trackPoints2, firstValidTimeInTrack2);
                displayStatistics(2);
                displayKilometerMarkers(2);
            }
        }

        function createKilometerMarkers(points, firstValidTime) {
            const markers = [];
            if (points.length === 0) return markers;
        
            const totalTrackDistance = points[points.length - 1].distance;
            let lastKmMarkerTime = firstValidTime;
            let cumulativeGain = 0, cumulativeLoss = 0;
        
            for (let km = 1; (km - 1) * 1000 < totalTrackDistance; km++) {
                const targetDistance = Math.min(km * 1000, totalTrackDistance); 
                let markerPoint = null;
                let pointIndexForSegmentStart = (markers.length > 0 && markers[markers.length - 1].originalPointIndex < points.length -1) 
                                                ? markers[markers.length - 1].originalPointIndex + 1 : 0;
                let segmentEleGain = 0, segmentEleLoss = 0;
        
                for (let i = pointIndexForSegmentStart; i < points.length - 1; i++) {
                    if (points[i].distance <= targetDistance && points[i+1].distance >= targetDistance) {
                        const p1 = points[i], p2 = points[i+1];
                        const segmentDist = p2.distance - p1.distance;
                        const ratio = segmentDist === 0 ? 0 : (targetDistance - p1.distance) / segmentDist;
                        
                        markerPoint = {
                            km: km, distance: targetDistance,
                            lat: p1.lat + (p2.lat - p1.lat) * ratio,
                            lon: p1.lon + (p2.lon - p1.lon) * ratio,
                            ele: (p1.ele !== null && p2.ele !== null && !isNaN(p1.ele) && !isNaN(p2.ele)) ? p1.ele + (p2.ele - p1.ele) * ratio : (p1.ele !== null && !isNaN(p1.ele) ? p1.ele : (p2.ele !== null && !isNaN(p2.ele) ? p2.ele : null)),
                            time: (p1.time && p2.time && !isNaN(p1.time.getTime()) && !isNaN(p2.time.getTime())) ? new Date(p1.time.getTime() + (p2.time.getTime() - p1.time.getTime()) * ratio) : null,
                            originalPointIndex: i 
                        };
        
                        for (let j = pointIndexForSegmentStart; j <= i; j++) {
                            if (j > 0 && points[j].ele !== null && points[j-1].ele !== null && !isNaN(points[j].ele) && !isNaN(points[j-1].ele)) {
                                const diff = points[j].ele - points[j-1].ele;
                                if (diff > 0) segmentEleGain += diff; else segmentEleLoss += Math.abs(diff);
                            }
                        }
                        if (p1.ele !== null && p2.ele !== null && !isNaN(p1.ele) && !isNaN(p2.ele) && ratio > 0 && ratio < 1) { 
                             const interpolatedEleOnSegment = (p2.ele - p1.ele) * ratio;
                             if (interpolatedEleOnSegment > 0) segmentEleGain += interpolatedEleOnSegment; else segmentEleLoss += Math.abs(interpolatedEleOnSegment);
                        }
                        break; 
                    }
                }
        
                if (!markerPoint && targetDistance === totalTrackDistance && points.length > 0) { 
                    const lastPt = points[points.length - 1];
                    markerPoint = {
                        km: km, distance: lastPt.distance, lat: lastPt.lat, lon: lastPt.lon, ele: lastPt.ele, time: lastPt.time,
                        originalPointIndex: points.length > 1 ? points.length - 2 : 0
                    };
                    for (let j = pointIndexForSegmentStart; j < points.length; j++) {
                         if (j > 0 && points[j].ele !== null && points[j-1].ele !== null && !isNaN(points[j].ele) && !isNaN(points[j-1].ele)) {
                             const diff = points[j].ele - points[j-1].ele;
                             if (diff > 0) segmentEleGain += diff; else segmentEleLoss += Math.abs(diff);
                         }
                     }
                }
        
                if (markerPoint) {
                    cumulativeGain += segmentEleGain; cumulativeLoss += segmentEleLoss;
                    markerPoint.segmentElevationGain = segmentEleGain; markerPoint.segmentElevationLoss = segmentEleLoss;
                    markerPoint.cumulativeGain = cumulativeGain; markerPoint.cumulativeLoss = cumulativeLoss;
        
                    if (markerPoint.time && lastKmMarkerTime && !isNaN(markerPoint.time.getTime()) && !isNaN(lastKmMarkerTime.getTime()) && markerPoint.time.getTime() > lastKmMarkerTime.getTime()) {
                        markerPoint.segmentTime = (markerPoint.time.getTime() - lastKmMarkerTime.getTime()) / 1000;
                    } else if (markerPoint.time && markers.length === 0 && firstValidTime && !isNaN(markerPoint.time.getTime()) && !isNaN(firstValidTime.getTime()) && markerPoint.time.getTime() > firstValidTime.getTime()) { 
                        markerPoint.segmentTime = (markerPoint.time.getTime() - firstValidTime.getTime()) / 1000;
                    } else { markerPoint.segmentTime = null; }
        
                    if (markerPoint.time && firstValidTime && !isNaN(markerPoint.time.getTime()) && !isNaN(firstValidTime.getTime()) && markerPoint.time.getTime() >= firstValidTime.getTime()) {
                        markerPoint.cumulativeTime = (markerPoint.time.getTime() - firstValidTime.getTime()) / 1000;
                    } else { markerPoint.cumulativeTime = null; }
                    
                    markers.push(markerPoint);
                    if (markerPoint.time && !isNaN(markerPoint.time.getTime())) lastKmMarkerTime = markerPoint.time;
                }
                if (markerPoint?.distance >= totalTrackDistance || (!markerPoint && targetDistance >= totalTrackDistance)) break;
            }
        
            if (points.length > 0 && (markers.length === 0 || markers[markers.length-1].distance < totalTrackDistance)) {
                const lastPt = points[points.length - 1];
                let finalSegmentGain = 0, finalSegmentLoss = 0;
                let finalPointStart = (markers.length > 0 && markers[markers.length - 1].originalPointIndex < points.length -1) 
                                      ? markers[markers.length - 1].originalPointIndex + 1 : 0;
                
                for (let j = finalPointStart; j < points.length; j++) { 
                     if (j > 0 && points[j].ele !== null && points[j-1].ele !== null && !isNaN(points[j].ele) && !isNaN(points[j-1].ele)) {
                         const diff = points[j].ele - points[j-1].ele;
                         if (diff > 0) finalSegmentGain += diff; else finalSegmentLoss += Math.abs(diff);
                     }
                 }
                cumulativeGain += finalSegmentGain; cumulativeLoss += finalSegmentLoss;

                const finalMarker = {
                    km: Math.ceil(lastPt.distance / 1000), distance: lastPt.distance, lat: lastPt.lat, lon: lastPt.lon, ele: lastPt.ele, time: lastPt.time,
                    originalPointIndex: points.length > 1 ? points.length - 2 : 0,
                    segmentElevationGain: finalSegmentGain, segmentElevationLoss: finalSegmentLoss,
                    cumulativeGain: cumulativeGain, cumulativeLoss: cumulativeLoss,
                    segmentTime: (lastPt.time && lastKmMarkerTime && !isNaN(lastPt.time.getTime()) && !isNaN(lastKmMarkerTime.getTime()) && lastPt.time.getTime() > lastKmMarkerTime.getTime()) ? (lastPt.time.getTime() - lastKmMarkerTime.getTime()) / 1000 : ((lastPt.time && markers.length === 0 && firstValidTime && !isNaN(lastPt.time.getTime()) && !isNaN(firstValidTime.getTime()) && lastPt.time.getTime() > firstValidTime.getTime()) ? (lastPt.time.getTime() - firstValidTime.getTime())/1000 : null),
                    cumulativeTime: (lastPt.time && firstValidTime && !isNaN(lastPt.time.getTime()) && !isNaN(firstValidTime.getTime()) && lastPt.time.getTime() >= firstValidTime.getTime()) ? (lastPt.time.getTime() - firstValidTime.getTime()) / 1000 : null,
                };
                if (markers.length === 0 || markers[markers.length-1].distance < finalMarker.distance) {
                    markers.push(finalMarker);
                }
            }
            return markers;
        }

        function displayStatistics(fileIndex) {
            const points = fileIndex === 1 ? trackPoints1 : trackPoints2;
            const statsContainer = fileIndex === 1 ? statsContainer1 : statsContainer2;
            if (!points || points.length === 0 || !statsContainer) return;

            const stats = {
                pointCount: points.length,
                distance: points.length > 0 ? points[points.length - 1].distance : 0,
                duration: calculateDuration(points), 
                avgSpeed: 0, maxElevation: -Infinity, minElevation: Infinity,
                elevationGain: 0, elevationLoss: 0
            };

            if (stats.distance > 0 && stats.duration > 0) {
                stats.avgSpeed = (stats.distance / 1000) / (stats.duration / 3600);
            }

            let prevEle = null;
            points.forEach(point => {
                if (point.ele !== null && !isNaN(point.ele)) {
                    stats.maxElevation = Math.max(stats.maxElevation, point.ele);
                    stats.minElevation = Math.min(stats.minElevation, point.ele);
                    if (prevEle !== null && !isNaN(prevEle)) {
                        const diff = point.ele - prevEle;
                        if (diff > 0) stats.elevationGain += diff;
                        else stats.elevationLoss += Math.abs(diff);
                    }
                    prevEle = point.ele;
                }
            });
             if (stats.maxElevation === -Infinity) stats.maxElevation = null;
             if (stats.minElevation === Infinity) stats.minElevation = null;

            statsContainer.innerHTML = '';
            const cardClass = `stat-card file${fileIndex}`;
            addStatCard(statsContainer, '포인트 수', `${stats.pointCount}개`, cardClass);
            addStatCard(statsContainer, '총 거리', `${(stats.distance / 1000).toFixed(2)} km`, cardClass);
            addStatCard(statsContainer, '소요 시간 (GPX)', formatDisplayDuration(stats.duration), cardClass);
            addStatCard(statsContainer, '평균 속도 (GPX)', `${stats.avgSpeed > 0 ? stats.avgSpeed.toFixed(1) : '-'} km/h`, cardClass);
            addStatCard(statsContainer, '최고 고도', stats.maxElevation !== null ? `${stats.maxElevation.toFixed(0)} m` : '-', cardClass);
            addStatCard(statsContainer, '최저 고도', stats.minElevation !== null ? `${stats.minElevation.toFixed(0)} m` : '-', cardClass);
            addStatCard(statsContainer, '총 상승 고도', `${stats.elevationGain.toFixed(0)} m`, cardClass);
            addStatCard(statsContainer, '총 하강 고도', `${stats.elevationLoss.toFixed(0)} m`, cardClass);
        }

        function addStatCard(container, title, value, cardClass = 'stat-card') {
            if(!container) return;
            const card = document.createElement('div');
            card.className = cardClass;
            card.innerHTML = `<div class="stat-title">${title}</div><div class="stat-value">${value}</div>`;
            container.appendChild(card);
        }

        function calculateDuration(points) { 
            if (points.length < 2) return 0;
            const firstTimePoint = points.find(p => p.time instanceof Date && !isNaN(p.time.getTime()));
            const lastTimePoint = [...points].reverse().find(p => p.time instanceof Date && !isNaN(p.time.getTime()));
            return (firstTimePoint && lastTimePoint && lastTimePoint.time.getTime() > firstTimePoint.time.getTime()) 
                   ? (lastTimePoint.time.getTime() - firstTimePoint.time.getTime()) / 1000 : 0;
        }

        function calculateDistance(lat1, lon1, lat2, lon2) { 
            if (isNaN(lat1) || isNaN(lon1) || isNaN(lat2) || isNaN(lon2)) return 0;
            const R = 6371000; 
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            if (dLat === 0 && dLon === 0) return 0; 
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        function initializeMap() {
            if (map) return;
            const mapElement = document.getElementById('map');
            if (!mapElement) { console.error("Map element not found!"); return; }
            mapElement.innerHTML = ''; 
            map = L.map('map', { zoomControl: true });
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);
        }

        function displayMap() {
            if (!map) initializeMap(); 
            if (!map) return; 

            if (trackLayer1) { map.removeLayer(trackLayer1); trackLayer1 = null; }
            if (startMarker1) { map.removeLayer(startMarker1); startMarker1 = null; }
            if (endMarker1) { map.removeLayer(endMarker1); endMarker1 = null; }
            if (trackLayer2) { map.removeLayer(trackLayer2); trackLayer2 = null; }
            if (startMarker2) { map.removeLayer(startMarker2); startMarker2 = null; }
            if (endMarker2) { map.removeLayer(endMarker2); endMarker2 = null; }

            let bounds = L.latLngBounds();

            if (trackPoints1.length > 0) {
                const latLngs1 = trackPoints1.map(p => [p.lat, p.lon]);
                trackLayer1 = L.polyline(latLngs1, { color: fileColors[1].line, weight: 3 }).addTo(map);
                bounds.extend(trackLayer1.getBounds());
                startMarker1 = L.marker(latLngs1[0], { title: "시작점 (파일 1)" }).addTo(map).bindPopup("<b>시작점 (파일 1)</b>");
                endMarker1 = L.marker(latLngs1[latLngs1.length-1], { title: "종료점 (파일 1)" }).addTo(map).bindPopup("<b>종료점 (파일 1)</b>");
            }
            if (trackPoints2.length > 0) {
                const latLngs2 = trackPoints2.map(p => [p.lat, p.lon]);
                trackLayer2 = L.polyline(latLngs2, { color: fileColors[2].line, weight: 3 }).addTo(map);
                bounds.extend(trackLayer2.getBounds());
                startMarker2 = L.marker(latLngs2[0], { title: "시작점 (파일 2)" }).addTo(map).bindPopup("<b>시작점 (파일 2)</b>");
                endMarker2 = L.marker(latLngs2[latLngs2.length-1], { title: "종료점 (파일 2)" }).addTo(map).bindPopup("<b>종료점 (파일 2)</b>");
            }

            if (bounds.isValid()) {
                map.fitBounds(bounds, {padding: [50, 50]});
            } else if (trackPoints1.length === 0 && trackPoints2.length === 0) {
                 map.setView([37.5665, 126.9780], 10); 
            }
        }

        function displayElevationChart() {
            const canvas = document.getElementById('elevation-canvas');
            if (!canvas) { console.error('Elevation canvas not found'); return; }
            const ctx = canvas.getContext('2d');
            if (!ctx) { console.error('Could not get 2D context'); return; }

            if (elevationChart) { elevationChart.destroy(); elevationChart = null; }
            ctx.clearRect(0, 0, canvas.width, canvas.height); 

            const datasets = [];
            let hasData = false;

            if (trackPoints1.length > 0) {
                const elevationData1 = trackPoints1.filter(p => p.ele !== null && !isNaN(p.ele) && !isNaN(p.distance)).map(p => ({ x: p.distance / 1000, y: p.ele }));
                if (elevationData1.length > 0) {
                    datasets.push({
                        label: `${fileColors[1].name} (${fileColors[1].runnerEmoji})`,
                        data: elevationData1,
                        borderColor: fileColors[1].line,
                        backgroundColor: fileColors[1].fill,
                        fill: true, tension: 0.1, pointRadius: 0, borderWidth: 2
                    });
                    hasData = true;
                }
            }
            if (trackPoints2.length > 0) {
                const elevationData2 = trackPoints2.filter(p => p.ele !== null && !isNaN(p.ele) && !isNaN(p.distance)).map(p => ({ x: p.distance / 1000, y: p.ele }));
                 if (elevationData2.length > 0) {
                    datasets.push({
                        label: `${fileColors[2].name} (${fileColors[2].runnerEmoji})`,
                        data: elevationData2,
                        borderColor: fileColors[2].line,
                        backgroundColor: fileColors[2].fill,
                        fill: true, tension: 0.1, pointRadius: 0, borderWidth: 2
                    });
                    hasData = true;
                }
            }

            if (!hasData) {
                ctx.font = "16px Arial"; ctx.textAlign = "center"; ctx.fillStyle = "#888";
                ctx.fillText("고도 데이터 없음", canvas.width / 2, canvas.height / 2);
                removeChartIndicator(1); removeChartIndicator(2);
                return;
            }
            
            let combinedYValues = [];
            datasets.forEach(ds => combinedYValues.push(...ds.data.map(d => d.y)));
            const minEleOverall = Math.min(...combinedYValues);
            const maxEleOverall = Math.max(...combinedYValues);
            const yRange = maxEleOverall - minEleOverall;
            const yPadding = yRange === 0 ? 10 : Math.max(10, yRange * 0.1);

            elevationChart = new Chart(ctx, {
                type: 'line', data: { datasets: datasets },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    scales: {
                        x: { type: 'linear', title: { display: true, text: '거리 (km)' } },
                        y: { title: { display: true, text: '고도 (m)' }, min: Math.floor(minEleOverall - yPadding), max: Math.ceil(maxEleOverall + yPadding) }
                    },
                    plugins: { 
                        legend: { display: true, position: 'top' },
                        tooltip: {
                            enabled: true, mode: 'index', intersect: false,
                            callbacks: {
                                title: (tooltipItems) => tooltipItems[0] ? `거리: ${tooltipItems[0].parsed.x.toFixed(2)} km` : '',
                                label: (tooltipItem) => `${tooltipItem.dataset.label || ''}: ${tooltipItem.parsed.y.toFixed(1)} m`
                            }
                        }
                    },
                    interaction: { mode: 'index', intersect: false },
                }
            });
        }

        function displayKilometerMarkers(fileIndex) {
            const markers = fileIndex === 1 ? kmMarkers1 : kmMarkers2;
            const tableBody = fileIndex === 1 ? kmMarkersTableBody1 : kmMarkersTableBody2;
            if(!tableBody) return;
            tableBody.innerHTML = ''; 
            if (markers.length === 0) {
                const row = tableBody.insertRow();
                const cell = row.insertCell();
                cell.colSpan = 8; cell.textContent = '구간 정보가 없습니다.'; cell.style.textAlign = 'center';
                return;
            }
            markers.forEach((marker, index) => {
                const row = tableBody.insertRow();
                const prevKm = index === 0 ? 0 : (typeof markers[index-1].km === 'number' ? markers[index-1].km : index);
                const displayKm = typeof marker.km === 'number' ? marker.km : prevKm + 1; 
                row.insertCell().textContent = `${prevKm} - ${displayKm}`;
                row.insertCell().textContent = (marker.distance / 1000).toFixed(2);
                row.insertCell().textContent = formatDisplayDuration(marker.segmentTime);
                row.insertCell().textContent = formatDisplayDuration(marker.cumulativeTime);
                row.insertCell().textContent = !isNaN(marker.segmentElevationGain) ? marker.segmentElevationGain.toFixed(0) : '-';
                row.insertCell().textContent = !isNaN(marker.segmentElevationLoss) ? marker.segmentElevationLoss.toFixed(0) : '-';
                row.insertCell().textContent = !isNaN(marker.cumulativeGain) ? marker.cumulativeGain.toFixed(0) : '-';
                row.insertCell().textContent = !isNaN(marker.cumulativeLoss) ? marker.cumulativeLoss.toFixed(0) : '-';
            });
        }

        function formatDisplayDuration(totalSeconds) {
            if (totalSeconds === null || totalSeconds === undefined || isNaN(totalSeconds) || totalSeconds < 0) return '--:--:--';
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = Math.floor(totalSeconds % 60);
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        function togglePlayPause() {
            if (isPlaying) pauseAnimation(); else startAnimation();
        }

        function startAnimation() {
            if (isPlaying || (trackPoints1.length === 0 && trackPoints2.length === 0)) return;
             // 애니메이션이 끝났으면 리셋
            if (normalizedProgress >= 1.0) {
                normalizedProgress = 0;
                // 즉시 초기 위치로 업데이트하여 사용자에게 리셋되었음을 명확히 보여줌
                updateAllRunnerPositions(); 
            }
            isPlaying = true;
            if(playPauseBtn) playPauseBtn.textContent = '❚❚';
            lastTimestamp = performance.now(); 
            animateTrack(lastTimestamp);
        }

        function pauseAnimation() {
            if (!isPlaying) return;
            isPlaying = false;
            if(playPauseBtn) playPauseBtn.textContent = '▶'; // 항상 재생 가능하도록 표시
            cancelAnimationFrame(animationFrameId);
        }

        function resetAnimation() {
            pauseAnimation(); // 현재 애니메이션 중지 및 버튼 상태 업데이트
            normalizedProgress = 0;
            updateAllRunnerPositions(); // 모든 주자 위치를 시작점으로 업데이트
            checkPlaybackAvailability(); 
        }
        
        function animateTrack(timestamp) { 
            if (!isPlaying) return;
        
            const actualDeltaTime = (timestamp - lastTimestamp) / 1000; 
            lastTimestamp = timestamp;
        
            const baseDurationSeconds = 60; 
            normalizedProgress += (1 / baseDurationSeconds) * playbackSpeed * actualDeltaTime;
        
            if (normalizedProgress >= 1.0) {
                normalizedProgress = 1.0; // 정확히 1.0으로 설정
                updateAllRunnerPositions(); // 마지막 위치 업데이트
                pauseAnimation(); // 여기서 playPauseBtn 텍스트가 '▶'로 바뀜
            } else {
                updateAllRunnerPositions();
                animationFrameId = requestAnimationFrame(animateTrack);
            }
        }

        function updateAllRunnerPositions() {
            if (trackPoints1.length > 0) {
                const targetIndex1 = normalizedProgress * (trackPoints1.length - 1);
                updateRunnerPositionForFile(1, targetIndex1);
            } else { // 파일1이 없으면 정보 숨김
                 if(currentInfo1El) currentInfo1El.style.display = 'none';
                 if(runnerLeafletMarker1 && map) { map.removeLayer(runnerLeafletMarker1); runnerLeafletMarker1 = null; }
                 removeChartIndicator(1);
            }

            if (trackPoints2.length > 0) {
                const targetIndex2 = normalizedProgress * (trackPoints2.length - 1);
                updateRunnerPositionForFile(2, targetIndex2);
            } else { // 파일2가 없으면 정보 숨김
                if(currentInfo2El) currentInfo2El.style.display = 'none';
                if(runnerLeafletMarker2 && map) { map.removeLayer(runnerLeafletMarker2); runnerLeafletMarker2 = null; }
                removeChartIndicator(2);
            }
        }
        
        function getRunnerIconHtml(fileIndex, distanceKm) {
            const runnerEmoji = fileColors[fileIndex].runnerEmoji;
            const color = fileColors[fileIndex].line;
            const distText = distanceKm.toFixed(1);
            return `<span style="color:${color};">${runnerEmoji} ${distText}km</span>`;
        }

        function createOrUpdateRunnerMarker(fileIndex, latLng, distanceKm) {
            let runnerMarker = fileIndex === 1 ? runnerLeafletMarker1 : runnerLeafletMarker2;
            const iconHtml = getRunnerIconHtml(fileIndex, distanceKm);
            const newIcon = L.divIcon({
                className: 'runner-leaflet-div-icon',
                html: iconHtml,
                iconSize: null, // Let Leaflet/CSS handle size based on content
                iconAnchor: [20, 10] // Adjust if necessary, e.g., half of estimated width, half of height
            });

            if (runnerMarker) {
                runnerMarker.setLatLng(latLng).setIcon(newIcon);
            } else {
                runnerMarker = L.marker(latLng, { icon: newIcon, zIndexOffset: 1000 + fileIndex });
                if (map) runnerMarker.addTo(map); // Add to map only if map exists
                if (fileIndex === 1) runnerLeafletMarker1 = runnerMarker;
                else runnerLeafletMarker2 = runnerMarker;
            }
             if (runnerMarker && isPlaying && map && map.getBounds().contains(runnerMarker.getLatLng()) === false) {
                map.panTo(runnerMarker.getLatLng(), { animate: true, duration: 0.1 });
            }
        }

        function createChartIndicator(fileIndex) {
            removeChartIndicator(fileIndex); 

            const indicatorLine = document.createElement('div');
            indicatorLine.className = 'chart-position-indicator';
            indicatorLine.id = `chart-position-indicator-${fileIndex}`;
            indicatorLine.style.backgroundColor = fileColors[fileIndex].line;
            elevationChartContainer.appendChild(indicatorLine);

            const indicatorDot = document.createElement('div');
            indicatorDot.className = 'chart-position-dot';
            indicatorDot.id = `chart-position-dot-${fileIndex}`;
            indicatorDot.style.backgroundColor = fileColors[fileIndex].line;
            elevationChartContainer.appendChild(indicatorDot);

            if (fileIndex === 1) {
                chartPositionIndicator1 = indicatorLine;
                chartPositionDot1 = indicatorDot;
            } else {
                chartPositionIndicator2 = indicatorLine;
                chartPositionDot2 = indicatorDot;
            }
        }

        function removeChartIndicator(fileIndex) {
            const lineId = `chart-position-indicator-${fileIndex}`;
            const dotId = `chart-position-dot-${fileIndex}`;
            const line = document.getElementById(lineId);
            if (line) line.remove();
            const dot = document.getElementById(dotId);
            if (dot) dot.remove();

            if (fileIndex === 1) {
                if (chartPositionIndicator1?.id === lineId) chartPositionIndicator1 = null;
                if (chartPositionDot1?.id === dotId) chartPositionDot1 = null;
            } else {
                if (chartPositionIndicator2?.id === lineId) chartPositionIndicator2 = null;
                if (chartPositionDot2?.id === dotId) chartPositionDot2 = null;
            }
        }

        function updateRunnerPositionForFile(fileIndex, targetIndexFloat) {
            const trackPoints = fileIndex === 1 ? trackPoints1 : trackPoints2;
            const firstValidTime = fileIndex === 1 ? firstValidTimeInTrack1 : firstValidTimeInTrack2;
            const currentDistEl = fileIndex === 1 ? currentDistance1El : currentDistance2El;
            const currentEleEl = fileIndex === 1 ? currentElevation1El : currentElevation2El;
            const currentTimeEl = fileIndex === 1 ? currentTime1El : currentTime2El;
            const currentInfoEl = fileIndex === 1 ? currentInfo1El : currentInfo2El;
            
            let chartIndicator = fileIndex === 1 ? chartPositionIndicator1 : chartPositionIndicator2;
            let chartDot = fileIndex === 1 ? chartPositionDot1 : chartPositionDot2;

            if (!map || trackPoints.length === 0) {
                if(currentInfoEl) currentInfoEl.style.display = 'none';
                // Runner marker removal is handled in resetDataForFile or updateAllRunnerPositions
                if(chartIndicator) chartIndicator.style.display = 'none';
                if(chartDot) chartDot.style.display = 'none';
                return;
            }
            if(currentInfoEl) currentInfoEl.style.display = 'flex';

            if (!chartIndicator || !chartDot) { // Create if not exists (e.g., after file load)
                 createChartIndicator(fileIndex);
                 chartIndicator = fileIndex === 1 ? chartPositionIndicator1 : chartPositionIndicator2;
                 chartDot = fileIndex === 1 ? chartPositionDot1 : chartPositionDot2;
            }

            let i = Math.floor(targetIndexFloat);
            i = Math.max(0, Math.min(i, trackPoints.length - 1));
            const p1 = trackPoints[i];
            const p2 = trackPoints[Math.min(i + 1, trackPoints.length - 1)]; 
            let ratio = Math.max(0, Math.min(targetIndexFloat - i, 1));
            if (i === trackPoints.length -1 || p1 === p2) ratio = 0; 
        
            if (!p1 || !p2 || isNaN(p1.lat) || isNaN(p1.lon) || isNaN(p2.lat) || isNaN(p2.lon)) return;

            const interpolatedLat = p1.lat + (p2.lat - p1.lat) * ratio;
            const interpolatedLon = p1.lon + (p2.lon - p1.lon) * ratio;
            
            let interpolatedEle = null;
            if (p1.ele !== null && !isNaN(p1.ele) && p2.ele !== null && !isNaN(p2.ele)) {
                interpolatedEle = p1.ele + (p2.ele - p1.ele) * ratio;
            } else interpolatedEle = p1.ele ?? p2.ele;

            const interpolatedDist = p1.distance + (p2.distance - p1.distance) * ratio;
            
            let interpolatedTime = null;
            if (p1.time && !isNaN(p1.time.getTime()) && p2.time && !isNaN(p2.time.getTime())) {
                const timeMs = p1.time.getTime() + (p2.time.getTime() - p1.time.getTime()) * ratio;
                interpolatedTime = new Date(timeMs);
            } else interpolatedTime = p1.time ?? p2.time;
        
            // Create or update runner marker on map
            createOrUpdateRunnerMarker(fileIndex, [interpolatedLat, interpolatedLon], interpolatedDist / 1000);
        
            if (elevationChart?.chartArea && elevationChart.scales?.x?.getPixelForValue && elevationChart.scales?.y?.getPixelForValue) { 
                const chartArea = elevationChart.chartArea;
                const xPixel = elevationChart.scales.x.getPixelForValue(interpolatedDist / 1000);
                
                if (chartIndicator && !isNaN(xPixel) && xPixel >= chartArea.left && xPixel <= chartArea.right) {
                    chartIndicator.style.left = `${xPixel}px`;
                    chartIndicator.style.display = 'block';
        
                    if (chartDot && interpolatedEle !== null && !isNaN(interpolatedEle)) {
                        const yPixel = elevationChart.scales.y.getPixelForValue(interpolatedEle);
                         if (!isNaN(yPixel) && yPixel >= chartArea.top && yPixel <= chartArea.bottom) {
                            chartDot.style.left = `${xPixel}px`;
                            chartDot.style.top = `${yPixel}px`;
                            chartDot.style.display = 'block';
                        } else if(chartDot) chartDot.style.display = 'none';
                    } else if(chartDot) chartDot.style.display = 'none';
                } else {
                    if(chartIndicator) chartIndicator.style.display = 'none';
                    if(chartDot) chartDot.style.display = 'none';
                }
            }
        
            if(currentDistEl) currentDistEl.textContent = `거리: ${(isNaN(interpolatedDist) ? 0 : interpolatedDist / 1000).toFixed(1)}km`;
            if(currentEleEl) currentEleEl.textContent = `고도: ${(interpolatedEle !== null && !isNaN(interpolatedEle)) ? interpolatedEle.toFixed(0) : '-'}m`;
            
            let timeToDisplay = '--:--:--';
            if (firstValidTime && interpolatedTime && !isNaN(interpolatedTime.getTime()) && !isNaN(firstValidTime.getTime())) {
                const elapsedSeconds = (interpolatedTime.getTime() - firstValidTime.getTime()) / 1000;
                timeToDisplay = formatDisplayDuration(Math.max(0, elapsedSeconds)); 
            }
            if(currentTimeEl) currentTimeEl.textContent = `시간: ${timeToDisplay}`;
        }

        // Initialize
        initializeMap();
        checkPlaybackAvailability();
        resetAnimation(); 
    </script>
</body>
</html>
